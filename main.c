/*
 ******************************************************************************
File:     main.c
Info:     Generated by Atollic TrueSTUDIO(R) 9.3.0   2021-04-09

The MIT License (MIT)
Copyright (c) 2019 STMicroelectronics

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

 ******************************************************************************
 */

/* Includes */
#include <stddef.h>
#include "stm32f10x.h"
#include <stdio.h>
#include <string.h>
#include "stm32f10x_gpio.h"
#include "stm32f10x_rcc.h"
#include "stm32f1xx_it.h"
#include "stm32f10x_usart.h"
#include "stm32f10x_rcc.h"
#include "stm32f10x_adc.h"

#define PUSHED 0
#define virtualGround 2500
USART_InitTypeDef USART_InitStructure;
NVIC_InitTypeDef NVIC_InitStructure;
int cnt1= 0;
int cnt2= 0;
int val =0;
int val1 =0;
uint16_t adcvalues[5]={0,0,0,0,0};
uint16_t adcvals[4]={0,0,0,0};
char string[]= {"HELLO WORLD"};
char freq_array[] = { 'A', 'B', 'C', 'D', 'E', '\r'};
char volt_array[] = { '2', '9', '1', '.', '4', '\r'};
#define colcount 20
#define rowcount 4
uint8_t LCD_Array[rowcount][colcount];
static unsigned char FSMcounter;
static unsigned char ADCcounter;
/* Private function prototypes */

static enum {FSM_IDLE_RESET,
	FSM_START,
	FSM_CURRENT_SENSE,
	FSM_CS_ERROR,
	FSM_DCBIAS_TEST,
	FSM_DCBIAS_ERROR,
	FSM_ACBIAS_TEST,
	FSM_ACBIAS_ERROR,
	FSM_RESULTS
} current_state;

/* Private functions */
void TIM4_Init(void);
void TIM3_Init(void);
void LED_init(void);
void TIM4_IRQHandler(void);
void delayus(int uS);
void TIM3_IRQHandler(void);
void delayms(int mS);
void setupSPI(void);
void sendData( uint8_t data);
void send_string_SPI(char *str);
void send_char_SPI(char c);
void cleararray(void);
void SPI_Lcd_Out(char row, char column, char string[]);
void ADCInit(void);
void ADC1_2_IRQHandler(void);
void slowdownclock(void);
void lcd_init (void);
void lcd_clear (void);
void lcd_send_data (char data);
void lcd_send_string (char *str);
void lcd_send_cmd (char cmd);
void Pushbutton_init(void);
void ADCChannelSelect(uint8_t adcchannel);
//void ADCISR(void);
void ReadingMultipleADCs(uint8_t adcchannel1,uint8_t adcchannel2,uint8_t adcchannel3);
void MULTIPLEADCISR(void);
void fsm_opamp_init(void);
void fsm_opamp(void);
void openingmessage(void);
//static unsigned char timed_to_1ms(void);
/**
 **===========================================================================
 **
 **  Abstract: main program
 **
 **===========================================================================
 */
int main(void)
{
	printf("get start\n");
	//slowdownclock();
	printf("get start\n");
	TIM4_Init();
	TIM3_Init();
	LED_init();
	setupSPI();
	ADCInit();
	Pushbutton_init();
	printf("get start\n");

	fsm_opamp_init();

	while(1)  {


		fsm_opamp();

	}

}

/********************************************************************
 * Function:        void fsm_opamp_init(void)
 * PreCondition:    None
 * Input:           None
 * Output:          None
 * Overview:        This init sets the start state for this FSM
 ********************************************************************/
void fsm_opamp_init(void) {
	current_state = FSM_IDLE_RESET;
	FSMcounter =0;
	ADCcounter =0;
}

/********************************************************************
 * Function:        void fsm_game(void)
 * PreCondition:    None
 * Input:           None
 * Output:          None
 * Overview:        An implementation for a simple OPAMP tester
 ********************************************************************/
void fsm_opamp(void) {

	switch (current_state) {
	case FSM_IDLE_RESET :
		// *** outputs ***
		if (FSMcounter==0){
			openingmessage();
			FSMcounter++;
		}


		// *** transitions ***
		if ((GPIOB->IDR &(GPIO_IDR_IDR9))==0){

			current_state = FSM_START  ;
			break;
		}
		if ((GPIOB->IDR &(GPIO_IDR_IDR8))==0){
			current_state = FSM_IDLE_RESET;
			break;
		}
		break;

	case  FSM_START :
		// *** outputs ***
		sendData(0x0C);
		sendData(0x04);
		sendData(0x11);
		sendData(0x04);
		sendData(0x00);
		delayms(10);
		send_string_SPI("FSM start\r");

		// *** transitions ***
		if ((GPIOB->IDR &(GPIO_IDR_IDR8))==0){
			current_state = FSM_IDLE_RESET;
			FSMcounter=0;
			break;
		}
		current_state = FSM_CURRENT_SENSE;
		break;

	case FSM_CURRENT_SENSE :
		// *** outputs ***
		sendData(0x04);
		sendData(0x11);
		sendData(0x04);
		sendData(0x01);
		delayms(10);
		send_string_SPI("CURRENT SENSE\r");
		ADCChannelSelect(4);
		ADC1_2_IRQHandler();
		//ADCcounter++;
		adcvalues[ADCcounter]=val1;
		ADCcounter++;

		// *** transitions ***
		if (val > 25) {
			current_state =  FSM_CS_ERROR;
			break;
		}
		if (val<=25){
			current_state = FSM_DCBIAS_TEST;
			break;
		}
		if ((GPIOB->IDR &(GPIO_IDR_IDR8))==0){
			current_state = FSM_IDLE_RESET;
			FSMcounter=0;
			break;
		}
		break;

	case FSM_CS_ERROR :
		// *** outputs ***
		sendData(0x0C);
		sendData(0x04);
		sendData(0x11);
		sendData(0x06);
		sendData(0x00);
		delayms(10);
		send_string_SPI("Fualty Device\r");
		sendData(0x11);
		sendData(0x03);
		sendData(0x01);
		send_string_SPI("using Large Current \r");


		// *** transitions ***
		if ((GPIOB->IDR &(GPIO_IDR_IDR8))==0) {
			current_state = FSM_IDLE_RESET;
			FSMcounter=0;
			break;
		}

		break;

	case FSM_DCBIAS_TEST :
		// *** outputs ***
		ADCChannelSelect(5);
		delayms(2);
		ADC1_2_IRQHandler();
		adcvalues[ADCcounter]=val1;
		ADCcounter++;
		ADCChannelSelect(6);
		delayms(2);
		ADC1_2_IRQHandler();
		adcvalues[ADCcounter]=val1;
		ADCcounter++;
		ADCChannelSelect(7);
		delayms(2);
		ADC1_2_IRQHandler();
		adcvalues[ADCcounter]=val1;
		ADCcounter++;

		// *** transitions ***
		if ((GPIOB->IDR &(GPIO_IDR_IDR8))==0) {
			current_state = FSM_IDLE_RESET;
			FSMcounter=0;
			break;
		}
		if ((adcvalues[0] | adcvalues[1] |adcvalues[2])>virtualGround){
			current_state = FSM_DCBIAS_ERROR ;
			break;
		}
		if ((adcvalues[1]|adcvalues[2]|adcvalues[3])<=virtualGround){
			current_state = FSM_ACBIAS_TEST;
			break;
		}
		break;

	case FSM_DCBIAS_ERROR :
		// *** outputs ***
		sendData(0x0C);
		sendData(0x04);
		sendData(0x11);
		sendData(0x06);
		sendData(0x00);
		delayms(10);
		send_string_SPI("Fualty Device\r");
		sendData(0x11);
		sendData(0x00);
		sendData(0x01);
		send_string_SPI("Vp=Vn=Vout ! <= 2500mV \r");
		sendData(0x0C);
		// *** transitions ***
		if ((GPIOB->IDR &(GPIO_IDR_IDR8))==0) {
			current_state = FSM_IDLE_RESET;
			FSMcounter=0;
			break;
		}
		break;
	case FSM_ACBIAS_TEST :
		// *** outputs ***111
		ADCChannelSelect(5);
		ADC1_2_IRQHandler();
		adcvalues[ADCcounter]=val1;
		ADCcounter=0;

		// *** transitions ***
		if ((GPIOB->IDR &(GPIO_IDR_IDR8))==0){
			current_state = FSM_IDLE_RESET;
			FSMcounter=0;
			break;
		}
		if (val>2500){
			current_state = FSM_ACBIAS_ERROR;
			break;
		}
		if (val<=2500){
			current_state = FSM_RESULTS;
			break;
		}
		break;

	case FSM_ACBIAS_ERROR :
		// *** outputs ***
		// *** transitions ***
		if ((GPIOB->IDR &(GPIO_IDR_IDR8))==0){
			current_state = FSM_IDLE_RESET;
			FSMcounter=0;
			break;
		}
		break;
	case FSM_RESULTS :
		// *** outputs ***
		for(int i=0; i<5; i++){
            printf("ADC1 CH[%d]: [%d]\r",i,adcvalues[i]);
		}
		sendData(0x0C);
		sendData(0x04);
		sendData(0x11);
		sendData(0x00);
		sendData(0x00);
		delayms(10);
		send_string_SPI("Vp:    mV\r");
		delayms(50);
		//sendData(0x30);
		sendData(0x11);
		sendData(0x00);
		sendData(0x01);
		//lcd_send_cmd (0x80|0x40);
		send_string_SPI("Vn:     mV\r");
		delayms(50);
		//sendData(0x30);
		sendData(0x11);
		sendData(0x00);
		sendData(0x02);
		//lcd_send_cmd (0x80|0x1C);
		send_string_SPI("Vout:    mV\r");
		delayms(50);
		//sendData(0x30);
		sendData(0x11);
		sendData(0x00);
		sendData(0x03);
		//lcd_send_cmd (0x80|0x54);
		send_string_SPI("Current Used:    mA\r");
		delayms(50);

		// *** transitions ***
		if ((GPIOB->IDR &(GPIO_IDR_IDR8))==0){
			current_state = FSM_IDLE_RESET;
			FSMcounter=0;
			break;
		}
		break;

	default:
		current_state = FSM_IDLE_RESET;
		break;
	}

}

/*static unsigned char timed_to_1ms(void) {

	int counter=0;
	TIM4->CR1 |= TIM_CR1_CEN;
	while(!(TIM4->SR & TIM_SR_UIF))  //if updates occured
	{counter++;

	printf("count= %d\n",counter);
	}

	TIM4->SR &= ~TIM_SR_UIF;
	TIM4->CR1 &= ~ TIM_CR1_CEN;
	return 1;
}*/

void openingmessage(void){
	sendData(0x0C);
	delayms(1000);
	sendData(0x04);
	sendData(0x11);
	sendData(0x04);
	sendData(0x00);
	delayms(10);
	send_string_SPI("OPAMP TESTER\r");
	delayms(50);
	//sendData(0x30);
	sendData(0x11);
	sendData(0x06);
	sendData(0x01);
	//lcd_send_cmd (0x80|0x40);
	send_string_SPI("MCP 601\r");
	delayms(50);
	//sendData(0x30);
	sendData(0x11);
	sendData(0x06);
	sendData(0x02);
	//lcd_send_cmd (0x80|0x1C);
	send_string_SPI("GROUP T\r");
	delayms(50);
	//sendData(0x30);
	sendData(0x11);
	sendData(0x05);
	sendData(0x03);
	//lcd_send_cmd (0x80|0x54);
	send_string_SPI("KU LEUVEN\r");
	delayms(50);
	sendData(0x04);
	sendData(0x0C);
	sendData(0x11);
	sendData(0x04);
	sendData(0x00);
	delayms(10);
	send_string_SPI("PUT THE OPAMP\r");
	delayms(50);
	//sendData(0x30);
	sendData(0x11);
	sendData(0x00);
	sendData(0x01);
	//lcd_send_cmd (0x80|0x40);
	send_string_SPI("IN THE BOTTOM 8 PINS \r");
	delayms(50);
	//sendData(0x30);
	sendData(0x11);
	sendData(0x03);
	sendData(0x02);
	//lcd_send_cmd (0x80|0x1C);
	send_string_SPI(" OF SOCKET AND\r");
	delayms(50);
	//sendData(0x30);
	sendData(0x11);
	sendData(0x05);
	sendData(0x03);
	//lcd_send_cmd (0x80|0x54);
	send_string_SPI("PRESS STARTB\r");
	delayms(50);
}

void TIM4_Init(void){
	//enable TIM4 clock gating
	RCC->APB1ENR |= RCC_APB1ENR_TIM4EN;
	//config TIM4 with specific time base
	TIM4->PSC = 0;
	TIM4->ARR = 72;          //1MHZ frequency
	TIM4->CR1 |= TIM_CR1_URS; // only counter underflow/ overflow generates an update interupt
	TIM4->DIER |= TIM_DIER_UIE; //UIE: update interrupt enable
	TIM4->EGR |= TIM_EGR_UG;  // update generation
	//TIM4->CR1 |= TIM_CR1_CEN;  // counter timer
	NVIC_EnableIRQ(TIM4_IRQn); //abort Enable IRQ line for TIM4
}
void TIM3_Init(void){
	//enable TIM3 clock gating
	RCC->APB1ENR |= RCC_APB1ENR_TIM3EN;
	//config TIM3 with specific time base
	TIM3->PSC = 10;
	TIM3->ARR = 7200;          //100KHz frequency
	TIM3->CR1 |= TIM_CR1_URS; // only counter underflow/ overflow generates an update interupt
	TIM3->DIER |= TIM_DIER_UIE; //UIE: update interrupt enable
	TIM3->EGR |= TIM_EGR_UG;  // update generation
	//TIM3->CR1 |= TIM_CR1_CEN;  // counter timer
	NVIC_EnableIRQ(TIM3_IRQn); //abort Enable IRQ line for TIM3
}

void delayms(int mS){
	TIM3->CR1 |= TIM_CR1_CEN;
	cnt2=0;
	while(cnt2<mS);
	TIM3->CR1 &= ~ TIM_CR1_CEN;
}
void TIM3_IRQHandler(void){
	/*if(TIM3->SR & TIM_SR_UIF)  //if updates occured
	{
		cnt2++;
	}*/
	cnt2++;
	TIM3->SR &= ~TIM_SR_UIF;
}


void delayus(int uS){
	TIM4->CR1 |= TIM_CR1_CEN;
	cnt1=0;
	while(cnt1<uS);
	TIM4->CR1 &= ~ TIM_CR1_CEN;
}
void TIM4_IRQHandler(void){
	/*if(TIM4->SR & TIM_SR_UIF)  //if updates occured
	{
		cnt1++;
	}*/
	cnt1++;
	TIM4->SR &= ~TIM_SR_UIF;
}
void LED_init(void){
	//Enable GPIOB CLOCK

	RCC->APB2ENR |= RCC_APB2ENR_IOPBEN;
	// configuring GPIOB

	GPIOB->CRL  |= ((1<<20)|(1<<21)); // output 50MHZ
	GPIOB->CRL  &= ~((1<<22)|(1<<23)); // general purpose output


}

void Pushbutton_init(void){
	//Enable GPIOB CLOCK

	RCC->APB2ENR |= RCC_APB2ENR_IOPBEN |RCC_APB2ENR_AFIOEN;
	// configuring GPIOB
	GPIOB->CRH  &= ~(GPIO_CRH_CNF8_1|GPIO_CRH_CNF9_1|GPIO_CRH_CNF8_0|GPIO_CRH_CNF9_0);
	GPIOB->CRH  |= GPIO_CRH_CNF8_0|GPIO_CRH_CNF9_0;
	GPIOB->CRH  &= ~(GPIO_CRH_MODE8_0|GPIO_CRH_MODE8_1|GPIO_CRH_MODE9_0|GPIO_CRH_MODE9_1);
	GPIOB->IDR  |= GPIO_IDR_IDR8|GPIO_IDR_IDR9;

}

void setupSPI(void)
{
	RCC->APB2ENR |= RCC_APB2ENR_IOPBEN |RCC_APB2ENR_AFIOEN; //GPIOB enabling which is on APB2
	RCC->APB1ENR |= RCC_APB1ENR_SPI2EN; //enable SPI2
	//config GPIO for SPI CLK AND MOSI to enable as alternate ftn push pull (Master mode)
	GPIOB->CRH &= ~(GPIO_CRH_CNF12 | GPIO_CRH_MODE12|GPIO_CRH_CNF13 | GPIO_CRH_MODE13|GPIO_CRH_CNF14 | GPIO_CRH_MODE14 | GPIO_CRH_CNF15| GPIO_CRH_MODE15);
	GPIOB->CRH  |= ( GPIO_CRH_CNF12_1|GPIO_CRH_MODE12 | GPIO_CRH_CNF13_1| GPIO_CRH_MODE13|GPIO_CRH_CNF14_1|GPIO_CRH_CNF15_1| GPIO_CRH_MODE15);

	//configure SPI
	SPI2->CR1 |= SPI_CR1_BIDIMODE |SPI_CR1_BIDIOE| SPI_CR1_BR|SPI_CR1_MSTR|SPI_CR1_CPHA|SPI_CR1_CPOL;
	SPI2->CR2 |= SPI_CR2_SSOE;
	SPI2->CR1 |= SPI_CR1_SPE ;
	printf("SPICR1=%d\n",SPI2->CR1);
}
void sendData(uint8_t data)
{
	SPI2->DR = data;
	while (!(SPI2->SR &  SPI_SR_TXE));
}

void send_char_SPI( char c)
{
	SPI2->DR = c;
	/* Wait for transmission complete */
	while (!(SPI2->SR &  SPI_SR_TXE));
}


void send_string_SPI(char *str)
{
	// GPIOB->BSRR =GPIO_BSRR_BS12;
	// GPIOB->BSRR = GPIO_BSRR_BR12; //resetting pin12 / low
	while (*str) send_char_SPI (*str++);


	//GPIOB->BSRR =GPIO_BSRR_BS12;

}

void ADCInit(void)
{
	//ADC Configuration settings

	//Configuring ADC prescalar in RCC to not exceed more than 14MHz
	RCC->CFGR |= RCC_CFGR_ADCPRE_DIV6;
	//RCC->AHBENR |= RCC_AHBENR_DMA1EN;

	//RCC Clocks for ADC and Alternate function
	RCC->APB2ENR |= RCC_APB2ENR_ADC1EN|RCC_APB2ENR_AFIOEN|RCC_APB2ENR_IOPAEN;
	//Configuring the GPIO pins as input push pull
	GPIOA->CRL |= GPIO_CRL_CNF4_1;
	GPIOA->CRL &= ~(GPIO_CRL_CNF4_0);
	GPIOA->CRL |= GPIO_CRL_CNF5_1;
	GPIOA->CRL &= ~(GPIO_CRL_CNF5_0);
	GPIOA->CRL |= GPIO_CRL_CNF6_1;
	GPIOA->CRL &= ~(GPIO_CRL_CNF6_0);
	GPIOA->CRL |= GPIO_CRL_CNF7_1;
	GPIOA->CRL &= ~(GPIO_CRL_CNF7_0);

	//Enable the interrupt in NVIC
	NVIC_EnableIRQ(ADC1_2_IRQn);
	//Enable the end of conversion intterupt
	ADC1->CR1 |= ADC_CR1_EOCIE;


	//set the sampling rate for channel 5 and selected maximum sampling rate to get better conversion
	ADC1->SMPR2 |= ADC_SMPR2_SMP4_2|ADC_SMPR2_SMP4_1| ADC_SMPR2_SMP4_0;
	ADC1->SMPR2 |= ADC_SMPR2_SMP5_2|ADC_SMPR2_SMP5_1| ADC_SMPR2_SMP5_0;
	ADC1->SMPR2 |= ADC_SMPR2_SMP6_2|ADC_SMPR2_SMP6_1| ADC_SMPR2_SMP6_0;
	ADC1->SMPR2 |= ADC_SMPR2_SMP7_2|ADC_SMPR2_SMP7_1| ADC_SMPR2_SMP7_0;
	//set the 1st channel to convert in the sequence register
	/*ADC1->SQR3 |= 4<<0; //5<<0
		ADC1->SQR3 |= 5<<5; //5<<0
		ADC1->SQR3 |= 6<<10; //5<<0
		ADC1->SQR3 |= 7<<15; //5<<0
		ADC1->SQR1 |=ADC_SQR1_L_2 ;

		//turning SCAN mode and DMA on
		ADC1->CR1 |= ADC_CR1_SCAN;
		ADC1->CR2 |= ADC_CR2_DMA;

		// DMA settings

		DMA1_Channel1->CMAR = (uint32_t) adcvals;
		DMA1_Channel1->CPAR = (uint32_t) &ADC1->DR;
		DMA1_Channel1->CNDTR = 4;

		DMA1_Channel1->CCR |=  DMA_CCR1_MINC | DMA_CCR1_CIRC| DMA_CCR1_PSIZE_0|DMA_CCR1_MSIZE_0
				| DMA_CCR1_HTIE | DMA_CCR1_TEIE|DMA_CCR1_TCIE;
		DMA1_Channel1->CCR |= DMA_CCR1_EN;
		//run the calibrations
		ADC1->CR2 |= ADC_CR2_CAL;
		delayms(2);

		//Enabe the ADC for the first time and set it to contionus mode
		ADC1->CR2 |=ADC_CR2_ADON;
		delayms(1);

		//turn on again the ADC for the second time to actually turn it on
		ADC1->CR2 |= ADC_CR2_ADON;

		delayms(1);*/

}

void ADC1_2_IRQHandler(void)
{
	//printf("Hamid5I\n");
	//Check for end of conversion flag is set
	//the end of conversion flag is cleared by reading the data register
	//while(!(ADC1->SR & ADC_SR_EOC)){
	//printf("Hamid5I\n");

	//	val= ADC1->DR;
	//	}

	//val=(val*1000)/4096;
	//val=(val*3300)/1000;
	//printf("ADCvalue1= [%d]\r",val);
	if(ADC1->SR & ADC_SR_EOC){
		val1= ADC1->DR;
		val1=(val1*3300)/4096;
		//val1=(val1*3300)/1000;
		printf("ADCvalue= [%d]\r",val1);


	}

}

void ADCChannelSelect(uint8_t adcchannel){

	printf("channel no:%d\n",adcchannel);
	//set the 1st channel to convert in the sequence register
	ADC1->SQR3 |= adcchannel<<0; //5<<0
	//ADC1->SQR3 |= 11<<5; //5<<0
	//ADC1->SQR3 |= 12<<10; //5<<0
	//ADC1->SQR3 |= 13<<15; //5<<0
	//ADC1->SQR1 |=ADC_SQR1_L_0 ;

	//turning SCAN mode and DMA on
	ADC1->CR1 |= ADC_CR1_SCAN;
	//ADC1->CR2 |= ADC_CR2_DMA;

	// DMA settings

	/*DMA1_Channel1->CMAR = (uint32_t) adcvals;
		DMA1_Channel1->CPAR = (uint32_t) &ADC1->DR;
		DMA1_Channel1->CNDTR = 4;

		DMA1_Channel1->CCR |=  DMA_CCR1_MINC | DMA_CCR1_CIRC| DMA_CCR1_PSIZE_0|DMA_CCR1_MSIZE_0
				| DMA_CCR1_HTIE | DMA_CCR1_TEIE|DMA_CCR1_TCIE;
		DMA1_Channel1->CCR |= DMA_CCR1_EN;*/
	//run the calibrations
	ADC1->CR2 |= ADC_CR2_CAL;
	delayms(2);

	//Enabe the ADC for the first time and set it to contionus mode
	ADC1->CR2 |= ADC_CR2_ADON;
	delayms(1);

	//turn on again the ADC for the second time to actually turn it on
	ADC1->CR2 |= ADC_CR2_ADON;

	delayms(1);

}

void ADCISR(void){
	if(ADC1->SR & ADC_SR_EOC){
		printf("Hamid5I\n");

		val1= ADC1->DR;
		val1=(val1*1000)/4096;
		val1=(val1*3300)/1000;
		printf("ADCvalue= [%d]\r",val1);
	}

}

void ReadingMultipleADCs(uint8_t adcchannel1,uint8_t adcchannel2,uint8_t adcchannel3){
	//ADC Configuration settings

	//Configuring ADC prescalar in RCC to not exceed more than 14MHz
	RCC->CFGR |= RCC_CFGR_ADCPRE_DIV6;
	RCC->AHBENR |= RCC_AHBENR_DMA1EN;

	//RCC Clocks for ADC and Alternate function
	RCC->APB2ENR |= RCC_APB2ENR_ADC1EN|RCC_APB2ENR_AFIOEN|RCC_APB2ENR_IOPAEN;
	//Configuring the GPIO pins as input push pull
	GPIOA->CRL |= GPIO_CRL_CNF4_1;
	GPIOA->CRL &= ~(GPIO_CRL_CNF4_0);
	GPIOA->CRL |= GPIO_CRL_CNF5_1;
	GPIOA->CRL &= ~(GPIO_CRL_CNF5_0);
	GPIOA->CRL |= GPIO_CRL_CNF6_1;
	GPIOA->CRL &= ~(GPIO_CRL_CNF6_0);
	GPIOA->CRL |= GPIO_CRL_CNF7_1;
	GPIOA->CRL &= ~(GPIO_CRL_CNF7_0);

	//Enable the interrupt in NVIC
	//NVIC_EnableIRQ(ADC1_2_IRQn);
	//Enable the end of conversion intterupt
	//ADC1->CR1 |= ADC_CR1_EOCIE;


	//set the sampling rate for channel 5 and selected maximum sampling rate to get better conversion
	ADC1->SMPR2 |= ADC_SMPR2_SMP4_2|ADC_SMPR2_SMP4_1| ADC_SMPR2_SMP4_0;
	ADC1->SMPR2 |= ADC_SMPR2_SMP5_2|ADC_SMPR2_SMP5_1| ADC_SMPR2_SMP5_0;
	ADC1->SMPR2 |= ADC_SMPR2_SMP6_2|ADC_SMPR2_SMP6_1| ADC_SMPR2_SMP6_0;
	ADC1->SMPR2 |= ADC_SMPR2_SMP7_2|ADC_SMPR2_SMP7_1| ADC_SMPR2_SMP7_0;
	//set the 1st channel to convert in the sequence register
	ADC1->SQR3 |= 4<<0; //5<<0
	ADC1->SQR3 |= 11<<5; //5<<0
	ADC1->SQR3 |= 12<<10; //5<<0
	ADC1->SQR3 |= 13<<15; //5<<0
	ADC1->SQR1 |=ADC_SQR1_L_2 ;

	//turning SCAN mode and DMA on
	ADC1->CR1 |= ADC_CR1_SCAN;
	ADC1->CR2 |= ADC_CR2_DMA;

	// DMA settings

	DMA1_Channel1->CMAR = (uint32_t) adcvals;
	DMA1_Channel1->CPAR = (uint32_t) &ADC1->DR;
	DMA1_Channel1->CNDTR = 4;

	DMA1_Channel1->CCR |=  DMA_CCR1_MINC | DMA_CCR1_CIRC| DMA_CCR1_PSIZE_0|DMA_CCR1_MSIZE_0
			| DMA_CCR1_HTIE | DMA_CCR1_TEIE|DMA_CCR1_TCIE;
	DMA1_Channel1->CCR |= DMA_CCR1_EN;
	//run the calibrations
	ADC1->CR2 |= ADC_CR2_CAL;
	delayms(2);

	//Enabe the ADC for the first time and set it to contionus mode
	ADC1->CR2 |= ADC_CR2_ADON;
	delayms(1);

	//turn on again the ADC for the second time to actually turn it on
	ADC1->CR2 |= ADC_CR2_ADON;

	delayms(1);
}

void MULTIPLEADCISR(void){
	while ((DMA1->ISR & DMA_ISR_TCIF1) == 0) {
		//temp1++;

	}
	// Clear all interrupt flags
	DMA1->IFCR = (DMA_IFCR_CGIF1 | DMA_IFCR_CTEIF1 | DMA_IFCR_CHTIF1
			| DMA_IFCR_CTCIF1);
	for(int i=0; i<4; i++){

		adcvalues[i]=(adcvals[i]*1000)/4096;
		adcvalues[i]=(adcvalues[i]*3300)/1000;
		printf("ADC1 CH[%d]: [%d]\r",i,adcvalues[i]);
	}
}

void slowdownclock(void)
{
	//turn on external crystal
	RCC->CR |= RCC_CR_HSEON;
	printf("ready\n");

	//wait for HSE crystal be stable
	//while(!(RCC->CR & RCC_CR_HSERDY));
	printf("get start1\n");
	//activate prefetch buffer but it should already be on
	/* FLASH->ACR |= FLASH_ACR_PRFTBE;
	 printf("get start\n");
	 // Flash 1 wait state
	 FLASH->ACR &= ~(FLASH_ACR_LATENCY); //reset just to be sure
	 FLASH->ACR |= (uint32_t) FLASH_ACR_LATENCY_1;*/
	printf("get start\n");
	//configure RCC and PLL settings while PLL is off
	RCC->CFGR &= ~(RCC_CFGR_PLLSRC | RCC_CFGR_PLLXTPRE |  RCC_CFGR_PLLMULL); //reset

	RCC->CFGR &= ~(RCC_CFGR_PLLXTPRE);  //PLLXTPRE bit set to 0
	RCC->CFGR |= RCC_CFGR_PLLSRC;  //pll source
	RCC->CFGR |= RCC_CFGR_PLLMULL7;  //pll miultiplier
	RCC->CFGR |= RCC_CFGR_HPRE_DIV2; //AHB prescaler
	RCC->CFGR |= RCC_CFGR_PPRE1_DIV8; //APB1 presacaler
	RCC->CFGR |= RCC_CFGR_PPRE2_DIV4; //APB2 prescaler
	printf("get start111\n");
	//turn on PLL
	RCC->CR |= RCC_CR_PLLON;
	while (!(RCC->CR & RCC_CR_PLLRDY))
		;
	//set pll as clock source
	RCC->CFGR &= ~(RCC_CFGR_SW);
	RCC->CFGR |= RCC_CFGR_SW_PLL;
	while (!(RCC->CFGR & RCC_CFGR_SWS_PLL))
		;
	printf("get start222\n");
	SystemCoreClockUpdate();

	printf("get start333\n");
}

